/**
 * @file hyperneat.hpp
 * @author Bang Liu
 *
 * Definition of the HyperNEAT class.
 */
#ifndef MLPACK_METHODS_NE_HYPERNEAT_HPP
#define MLPACK_METHODS_NE_HYPERNEAT_HPP

#include <mlpack/core.hpp>

#include "link_gene.hpp"
#include "neuron_gene.hpp"
#include "genome.hpp"
#include "species.hpp"
#include "population.hpp"
#include "tasks.hpp"
#include "parameters.hpp"
#include "neat.hpp"
#include "substrate.hpp"

namespace mlpack {
namespace ne {

/**
 * This class defines HyperNEAT.
 */
template<typename TaskType>
class HyperNEAT
{
 public:
  // NEAT instance.
  NEAT<TaskType> aNeat;

  // Substrate.
  Substrate aSubstrate;

  /**
   * Parametric constructor.
   *
   * @param task The task to solve.
   * @param substrate The substrate configuration for the task.
   * @param seedGenome The genome to initialize population.
   * @param params The Parameter object that contains algorithm parameters.
   */
  HyperNEAT(TaskType task, Substrate& substrate, Genome& seedGenome, Parameters& params)
  {
    aNeat = NEAT<TaskType>(task, seedGenome, params);
    aSubstrate = substrate;  // New member compared with NEAT.
  }

  /**
   * Destructor.
   */
  ~HyperNEAT() {}

  /**
   * Evaluate genomes in population. 
   * Set genomes' fitness, species' and population's best fitness and genome.
   *
   * This is the key difference with NEAT. Thus need to override it.
   * Rather than evaluate each genome in population directly, we need to query 
   * the substrate to decide the connections in the substrate, and evaluate the 
   * substrate genome.
   */
  void Evaluate()
  {
  	Genome genome;  // The genome generated by the substrate.
  	aSubstrate.InitGenome(genome);

    for (int i=0; i<aNeat.aPopulation.aSpecies.size(); ++i)
    {
      for (int j=0; j<aNeat.aPopulation.aSpecies[i].aGenomes.size(); ++j)
      {
        aNeat.aPopulation.aSpecies[i].aGenomes[j].Flush();
        aSubstrate.QueryLink(aNeat.aPopulation.aSpecies[i].aGenomes[j], genome);  // Query weight.

        double fitness = aNeat.aTask.EvalFitness(genome);  // Evaluate genome generated by substrate.
        aNeat.aPopulation.aSpecies[i].aGenomes[j].Fitness(fitness);
      }

      double oldSpeciesBestFitness = aNeat.aPopulation.aSpecies[i].BestFitness();
      aNeat.aPopulation.aSpecies[i].SetBestFitnessAndGenome();
      double newSpeciesBestFitness = aNeat.aPopulation.aSpecies[i].BestFitness();
      if (newSpeciesBestFitness < oldSpeciesBestFitness)
      {
        aNeat.aPopulation.aSpecies[i].StaleAge(0);
      } else
      {
        int staleAge = aNeat.aPopulation.aSpecies[i].StaleAge();
        aNeat.aPopulation.aSpecies[i].StaleAge(staleAge + 1);
      }
    }
    aNeat.aPopulation.SetBestFitnessAndGenome();
  }

  /**
   * Evolve population of genomes to get a task's solution genome.
   *
   * This function is the whole progress of HyperNEAT algorithm.
   * It is almost the same with NEAT's Evolve. The difference is that
   * it use the Evaluate function defined in HyperNEAT.
   */
  bool Evolve()
  {
    // Generate initial species at random.
    int generation = 0;
    aNeat.InitPopulation();

    // Speciate genomes into species.
    std::vector<Genome> genomes;
    aNeat.AggregateGenomes(aNeat.aPopulation, genomes);
    aNeat.aPopulation.aSpecies.clear();
    for (int i=0; i<genomes.size(); ++i)
    {
      aNeat.AddGenomeToSpecies(aNeat.aPopulation, genomes[i]);
    }
    
    // Repeat
    while (generation < aNeat.aMaxGeneration)
    {
      // Evaluate all genomes in population.
      Evaluate();  // Here different with NEAT.

      // Output some information.
      printf("Generation: %zu\tBest fitness: %f\n", generation, aNeat.aPopulation.BestFitness());
      Log::Info << "Generation: " << generation << " best fitness: " <<  aNeat.aPopulation.BestFitness() << std::endl;
      if (aNeat.aTask.Success())
      {
        printf("Task succeed in %zu iterations.\n", generation);
        return true;
      }

      //Debug
      Genome bestGenome = aNeat.aPopulation.BestGenome();
      Genome substrateGenome;
      aSubstrate.InitGenome(substrateGenome);
      aSubstrate.QueryLinkDebug(bestGenome, substrateGenome);
      substrateGenome.PrintGenome();
      bestGenome.PrintGenome();

      // Reproduce next generation.
      aNeat.Reproduce();
      ++generation;
    }

    return false;
  }

 private:

};

}  // namespace ne
}  // namespace mlpack

#endif  // MLPACK_METHODS_NE_HYPERNEAT_HPP